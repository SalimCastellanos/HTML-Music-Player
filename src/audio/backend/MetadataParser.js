import getCodecName from "audio/backend/sniffer";
import FileView from "platform/FileView";
import parseMp3Metadata from "metadata/mp3_metadata";
import parseAcoustId from "metadata/acoustId";
import {sha1Binary, queryString, capitalize} from "util";
import {XMLHttpRequest} from "platform/platform";
import AcoustIdApiError, {ERROR_TIMEOUT, ERROR_INVALID_RESPONSE_SYNTAX} from "metadata/AcoustIdApiError";

const UNKNOWN = `Unknown`;
const separatorPattern = /(.+)\s*-\s*(.+)/;
export const stripExtensionPattern = new RegExp(`\\.(?:[a-z0-9_\\-]{1,8})$`, `i`);
const trackInfoFromFileName = function(inputFileName) {
    const fileName = inputFileName.replace(stripExtensionPattern, ``);
    const matches = fileName.match(separatorPattern);
    let artist, title;

    if (!matches) {
        title = capitalize(fileName);
        artist = UNKNOWN;
    } else {
        artist = capitalize(matches[1]) || UNKNOWN;
        title = capitalize(matches[2]) || UNKNOWN;
    }

    return {
        artist,
        title
    };
};

const codecNotSupportedError = function() {
    const e = new Error(`codec not supported`);
    e.name = `CodecNotSupportedError`;
    return e;
};

const ajaxGet = function(url) {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.timeout = 5000;

        function error() {
            reject(new AcoustIdApiError(`request timed out`, ERROR_TIMEOUT));
        }

        xhr.addEventListener(`load`, () => {
            try {
              const result = JSON.parse(xhr.responseText);
              resolve(result);
            } catch (e) {
              reject(e);
            }
        }, false);

        xhr.addEventListener(`abort`, error);
        xhr.addEventListener(`timeout`, error);
        xhr.addEventListener(`error`, () => {
            reject(new AcoustIdApiError(`Response status: ${xhr.status}`, ERROR_INVALID_RESPONSE_SYNTAX));
        });

        xhr.open(`GET`, url);
        xhr.send(null);
    });
};

export const getFileCacheKey = function(file) {
    return sha1Binary(`${file.lastModified}-${file.name}-${file.size}-${file.type}`);
};

function buildTrackInfo(metadata) {
    const {title = null, album = null, artist = null, albumArtist = null,
           year = null, albumIndex = 0, trackCount = 1,
           genres = [], duration} = metadata;
    return {
        lastPlayed: 0,
        rating: -1,
        playthroughCounter: 0,
        skipCounter: 0,
        title, album, artist, albumArtist, year, albumIndex, trackCount, genres,
        duration
    };
}

export default class MetadataParser {
    constructor(tagDatabase) {
        this._tagDatabase = tagDatabase;
        this._maxParsersActive = 8;
        this._parserQueue = [];
        this._parsersActive = 0;
        this._imageFetchQueue = [];
        this._currentlyFetchingImage = false;
    }

    _nextParse() {
        this._parsersActive--;
        if (this._parserQueue.length > 0) {
            const item = this._parserQueue.shift();
            this._parsersActive++;
            this._parse(item.file, item.uid, item.resolve);
        }
    }

    _nextImageFetch() {
        if (this._imageFetchQueue.length > 0) {
            const {acoustIdCoverArt, albumKey, resolve} = this._imageFetchQueue.shift();
            resolve(this._fetchAcoustIdImage(acoustIdCoverArt, albumKey));
        } else {
            this._currentlyFetchingImage = false;
        }
    }

    async _fetchAcoustIdImage(acoustIdCoverArt, albumKey) {
        const image = await this._tagDatabase.getAlbumImage(albumKey);
        if (image) {
            return image;
        }

        if (acoustIdCoverArt) {
            const {type, mbid} = acoustIdCoverArt;
            const url = `https://coverartarchive.org/${type}/${mbid}/front-250`;
            const ret = {url};
            this._tagDatabase.setAlbumImage(albumKey, url);
            return ret;
        } else {
            return null;
        }
    }

    async _parse(file, trackUid, resolve) {
        const cachedResult = await this._getCachedMetadata(trackUid);

        if (cachedResult) {
            resolve(cachedResult);
            return;
        }

        const data = {
            trackUid,
            codecName: null,
            duration: 0,
            autogenerated: false
        };
        const fileView = new FileView(file);
        const codecName = await getCodecName(fileView);
        if (!codecName) {
            throw codecNotSupportedError();
        }

        switch (codecName) {
            case `wav`:
            case `webm`:
            case `aac`:
            case `ogg`:
                throw codecNotSupportedError();
            case `mp3`:
                await parseMp3Metadata(data, fileView);
                break;
            default: break;
        }
        data.codecName = codecName;
        data.duration = data.demuxData.duration;
        data.trackUid = trackUid;

        if (!data.artist || !data.title) {
            const {artist, title} = trackInfoFromFileName(file.name);
            data.artist = artist;
            data.title = title;
            data.autogenerated = true;
        }

        const trackInfo = buildTrackInfo(data);
        trackInfo.cachedMetadata = data;
        await this._tagDatabase.replaceTrackInfo(trackUid, trackInfo);
        resolve(data);
    }

    async _getCachedMetadata(trackUid) {
        const trackInfo = await this._tagDatabase.getTrackInfoByTrackUid(trackUid);
        if (!trackInfo) {
            return null;
        }
        return trackInfo.cachedMetadata || null;
    }

    async getCachedMetadata(file) {
        const trackUid = await getFileCacheKey(file);
        return this._getCachedMetadata(trackUid);
    }

    async updateCachedMetadata(file, cachedMetadata) {
        let {trackUid} = cachedMetadata;
        if (!trackUid) {
            trackUid = await getFileCacheKey(file);
        }
        const trackInfo = await this._tagDatabase.getTrackInfoByTrackUid(trackUid);
        if (trackInfo) {
            cachedMetadata = Object.assign(trackInfo.cachedMetadata || {},
                                                 cachedMetadata ||Â {});
            trackInfo.cachedMetadata = cachedMetadata;
            await this._tagDatabase.replaceTrackInfo(trackUid, trackInfo);
        }
    }

    async fetchAcoustId(uid, fingerprint, duration) {
        const data = queryString({
            client: `djbbrJFK`,
            format: `json`,
            duration: duration | 0,
            meta: `recordings+releasegroups+compress`,
            fingerprint
        });
        const url = `https://api.acoustId.org/v2/lookup?${data}`;

        let result;
        let retries = 0;
        let fullResponse = null;
        while (retries < 5) {
            try {
                const response = await ajaxGet(url);
                if (response &&
                    response.status !== `error` &&
                    response.results &&
                    response.results.length > 0) {
                    fullResponse = response.results;
                }
                result = parseAcoustId(response);
                break;
            } catch (e) {
                if (!e.isRetryable()) {
                    throw e;
                }
                retries++;
            }
        }
        let acoustIdCoverArt = null;
        if (result) {
            const {album, title} = result;
            if (album && album.mbid) {
                acoustIdCoverArt = {
                    mbid: album.mbid,
                    type: album.type
                };
            } else if (title && title.mbid) {
                acoustIdCoverArt = {
                    mbid: title.mbid,
                    type: title.type
                };
            }
            await this._tagDatabase.setAcoustIdResponse(uid, fullResponse, acoustIdCoverArt);
        } else {
            await this._tagDatabase.setAcoustIdResponse(uid, fullResponse, null);
        }

        const trackInfo = await this._tagDatabase.getTrackInfoByTrackUid(uid);
        const metadata = trackInfo.cachedMetadata;
        const wasAutogenerated = metadata.autogenerated;
        metadata.autogenerated = false;
        trackInfo.acoustIdCoverArt = acoustIdCoverArt;

        let metadataUpdated = false;
        if (result) {
            const {album: albumResult = {},
                   title: titleResult = {},
                   artist: artistResult = {},
                   albumArtist: albumArtistResult} = result;
            const {name: album} = albumResult;
            const {name: title} = titleResult;
            const {name: artist} = artistResult;
            const {name: albumArtist} = albumArtistResult;

            if ((!trackInfo.title || wasAutogenerated) && title) {
                metadata.title = trackInfo.title = title;
                metadataUpdated = true;
            }

            if ((!trackInfo.album || wasAutogenerated) && album) {
                metadata.album = trackInfo.album = album;
                metadataUpdated = true;
            }

            if ((!trackInfo.albumArtist || wasAutogenerated) && albumArtist) {
                metadata.albumArtist = trackInfo.albumArtist = albumArtist;
                metadataUpdated = true;
            }

            if ((!trackInfo.artist || wasAutogenerated) && artist) {
                metadata.artist = trackInfo.artist = artist;
                metadataUpdated = true;
            }
        }

        await this._tagDatabase.replaceTrackInfo(uid, trackInfo);
        return {
            acoustIdCoverArt,
            metadata,
            metadataUpdated
        };
    }

    async parse(file, uid) {
        try {
            const ret = await new Promise((resolve) => {
                if (this._parsersActive >= this._maxParsersActive) {
                    this._parserQueue.push({
                        file,
                        resolve,
                        uid
                    });
                } else {
                    this._parsersActive++;
                    this._parse(file, uid, resolve);
                }
            });
            return ret;
        } finally {
            this._nextParse();
        }
    }

    async fetchAnalysisData(uid, albumKey) {
        const db = this._tagDatabase;
        const [data, albumImage] = await Promise.all([db.getTrackInfoByTrackUid(uid), db.getAlbumImage(albumKey)]);

        if (data) {
            if (albumImage) {
                data.albumImage = albumImage;
            }
        }
        return data;
    }

    async fetchAcoustIdImage(acoustIdCoverArt, albumKey) {
        const ret = new Promise((resolve) => {
            if (!this._currentlyFetchingImage) {
                this._currentlyFetchingImage = true;
                resolve(this._fetchAcoustIdImage(acoustIdCoverArt, albumKey));
            } else {
                this._imageFetchQueue.push({
                    acoustIdCoverArt, albumKey, resolve
                });
            }
        });

        try {
            const value = await ret;
            return value;
        } finally {
            this._nextImageFetch();
        }
    }
}

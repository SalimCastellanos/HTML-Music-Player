import getCodecName from "audio/backend/sniffer";
import FileView from "platform/FileView";
import parseMp3Metadata from "metadata/mp3_metadata";
import parseAcoustId from "metadata/acoustId";
import {sha1Binary, queryString, capitalize, toCorsUrl, _} from "util";
import {XMLHttpRequest, URL, Blob} from "platform/platform";
import HttpStatusError from "errors/HttpStatusError";
import JobProcessor from "utils/JobProcessor";

const IMAGE_TYPE_KEY = `imageType`;
const IMAGE_TYPE_COVERARTARCHIVE = `coverartarchive`;
const IMAGE_TYPE_BLOB = `blob`;

const imageTypeKeyWeights = {
    [IMAGE_TYPE_BLOB]: 0,
    [IMAGE_TYPE_COVERARTARCHIVE]: 1
};

export const ALBUM_ART_PREFERENCE_SMALLEST = `smallest`;
export const ALBUM_ART_PREFERENCE_BIGGEST = `biggest`;
export const ALBUM_ART_PREFERENCE_ALL = `all`;

const UNKNOWN = `Unknown`;
const separatorPattern = /(.+)\s*-\s*(.+)/;
export const stripExtensionPattern = new RegExp(`\\.(?:[a-z0-9_\\-]{1,8})$`, `i`);
const trackInfoFromFileName = function(inputFileName) {
    const fileName = inputFileName.replace(stripExtensionPattern, ``);
    const matches = fileName.match(separatorPattern);
    let artist, title;

    if (!matches) {
        title = capitalize(fileName);
        artist = UNKNOWN;
    } else {
        artist = capitalize(matches[1]) || UNKNOWN;
        title = capitalize(matches[2]) || UNKNOWN;
    }

    return {
        artist,
        title
    };
};

const codecNotSupportedError = function() {
    const e = new Error(`codec not supported`);
    e.name = `CodecNotSupportedError`;
    return e;
};

const ajaxGet = function(url) {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.timeout = 15000;

        function error() {
            reject(new HttpStatusError(408, `timeout`));
        }

        xhr.addEventListener(`load`, () => {
            if (xhr.status === 0 || xhr.status > 299) {
                reject(new HttpStatusError(xhr.status, xhr.responseText));
                return;
            }

            try {
              const result = JSON.parse(xhr.responseText);
              resolve(result);
            } catch (e) {
              reject(new HttpStatusError(500, xhr.responseText));
            }
        }, false);


        xhr.addEventListener(`timeout`, error);
        xhr.addEventListener(`error`, () => {
            reject(new HttpStatusError(0, `network error`));
        });

        xhr.open(`GET`, url);
        xhr.setRequestHeader(`Accept`, `application/json`);
        xhr.send(null);
    });
};

const runknown = /^[\s<{[(]*unknown[}\])>\s]*$/i;
const isUnknown = function(value) {
    if (!value) {
        return true;
    }
    return runknown.test(`${value}`);
};

export const getFileCacheKey = function(file) {
    return sha1Binary(`${file.lastModified}-${file.name}-${file.size}-${file.type}`);
};

function buildTrackInfo(metadata, demuxData) {
    const {title = null, album = null, artist = null, albumArtist = null,
           year = null, albumIndex = 0, trackCount = 1,
           genres = []} = metadata;
    return Object.assign({}, metadata, {
        lastPlayed: new Date(0),
        rating: -1,
        playthroughCounter: 0,
        skipCounter: 0,
        hasBeenAnalyzed: false,
        title, album, artist, albumArtist, year, albumIndex, trackCount, genres
    }, {
        sampleRate: demuxData.sampleRate,
        channels: demuxData.channels,
        duration: demuxData.duration
    });
}

export default class MetadataManager {
    constructor(tagDatabase) {
        this._tagDatabase = tagDatabase;
        this._parser = new JobProcessor({
            parallelJobs: 8,
            jobCallback: this._parse.bind(this)
        });
        this._blobUrls = [];
    }

    async _parse(job, file, trackUid) {
        let trackInfo = await this._tagDatabase.getTrackInfoByTrackUid(trackUid);

        if (trackInfo) {
            return trackInfo;
        }

        const data = {
            trackUid,
            codecName: null,
            duration: 0,
            autogenerated: false
        };
        const fileView = new FileView(file);
        const codecName = await getCodecName(fileView);
        if (!codecName) {
            throw codecNotSupportedError();
        }

        switch (codecName) {
            case `wav`:
            case `webm`:
            case `aac`:
            case `ogg`:
                throw codecNotSupportedError();
            case `mp3`:
                await parseMp3Metadata(data, fileView);
                break;
            default: break;
        }
        data.codecName = codecName;
        data.duration = data.demuxData.duration;
        data.trackUid = trackUid;

        if (!data.artist || !data.title) {
            const {artist, title} = trackInfoFromFileName(file.name);
            data.artist = artist;
            data.title = title;
            data.autogenerated = true;
        }

        if (data.pictures) {
            const {pictures} = data;
            delete data.pictures;
            await this._tagDatabase.addAlbumArtData(trackUid, {
                trackUid,
                images: pictures.map(i => Object.assign({[IMAGE_TYPE_KEY]: IMAGE_TYPE_BLOB}, i)),
                album: data.album || null,
                title: data.title
            });
        }

        trackInfo = buildTrackInfo(data, data.demuxData);
        await this._tagDatabase.replaceTrackInfo(trackUid, trackInfo);
        return trackInfo;
    }

    setEstablishedGain(trackUid, establishedGain) {
        return this._tagDatabase.updateEstablishedGain(trackUid, establishedGain);
    }

    async getTrackInfoByFile(file) {
        const trackUid = await getFileCacheKey(file);
        return this._tagDatabase.getTrackInfoByTrackUid(trackUid);
    }

    async fetchCoverArtInfo(acoustIdResult, trackInfo) {
        const {trackUid} = trackInfo;
        const {album, title} = acoustIdResult;
        let mbid, type;

        if (album && album.mbid) {
            ({mbid, type} = album);
        } else if (title && title.mbid) {
            ({mbid, type} = title);
        } else {
            return false;
        }

        const {artist: taggedArtist,
                album: taggedAlbum} = trackInfo;
        try {
            const response = await ajaxGet(toCorsUrl(`https://coverartarchive.org/${type}/${mbid}`));
            if (response && response.images && response.images.length > 0) {
                await this._tagDatabase.addAlbumArtData(trackUid, {
                    trackUid,
                    images: response.images.map(i => Object.assign({[IMAGE_TYPE_KEY]: IMAGE_TYPE_COVERARTARCHIVE}, i)),
                    artist: taggedArtist,
                    album: taggedAlbum
                });
                return true;
            }
        } catch (e) {
            if (e.status !== 404) {
                throw e;
            }
        }
        return false;
    }

    async fetchAcoustId(uid, fingerprint, duration) {
        const data = queryString({
            client: `djbbrJFK`,
            format: `json`,
            duration: duration | 0,
            meta: `recordings+releasegroups+compress`,
            fingerprint
        });
        const url = `https://api.acoustId.org/v2/lookup?${data}`;

        let result;
        const fullResponse = await ajaxGet(toCorsUrl(url));
        if (fullResponse.results && fullResponse.results.length > 0) {
            result = parseAcoustId(fullResponse);
        }
        const trackInfo = await this._tagDatabase.getTrackInfoByTrackUid(uid);
        const wasAutogenerated = trackInfo.autogenerated;

        let trackInfoUpdated = false;
        if (result) {
            trackInfo.autogenerated = false;
            const {album: albumResult,
                   title: titleResult,
                   artist: artistResult,
                   albumArtist: albumArtistResult} = result;
            const {name: album} = albumResult || {};
            const {name: title} = titleResult || {};
            const {name: artist} = artistResult || {};
            const {name: albumArtist} = albumArtistResult || {};

            if ((isUnknown(trackInfo.title) || wasAutogenerated) && title) {
                trackInfo.title = title;
                trackInfoUpdated = true;
            }

            if ((isUnknown(trackInfo.album) || wasAutogenerated) && album) {
                trackInfo.album = album;
                trackInfoUpdated = true;
            }

            if ((isUnknown(trackInfo.albumArtist) || wasAutogenerated) && albumArtist) {
                trackInfo.albumArtist = albumArtist;
                trackInfoUpdated = true;
            }

            if ((isUnknown(trackInfo.artist) || wasAutogenerated) && artist) {
                trackInfo.artist = artist;
                trackInfoUpdated = true;
            }
        }

        trackInfo.acoustIdFullResponse = fullResponse;
        await this._tagDatabase.replaceTrackInfo(uid, trackInfo);
        return {
            acoustIdResult: result ||Â null,
            trackInfo,
            trackInfoUpdated
        };
    }

    parseAudioFileMetadata(file, uid) {
        return this._parser.postJob(file, uid).promise;
    }

    _checkBlobList() {
        if (this._blobUrls.length > 25) {
            while (this._blobUrls.length > 12) {
                const url = this._blobUrls.shift();
                try {
                    URL.revokeObjectUrl(url);
                } catch (e) {
                    // NOOP
                }
            }
        }
    }

    _mapToUrl(value) {
        if (typeof value === `string`) {
            return value.replace(/^https?:\/\//i, `https://`);
        } else if (value instanceof Blob) {
            const url = URL.createObjectUrl(value);
            this._blobUrls.push(url);
            this._checkBlobList();
            return url;
        } else {
            throw new Error(`unknown value ${value} ${typeof value}`);
        }
    }

    async _getAlbumArt(trackUid, artist, album, preference) {
        const albumArtData = await this._tagDatabase.getAlbumArtData(trackUid, artist, album);

        if (!albumArtData) {
            return preference === ALBUM_ART_PREFERENCE_ALL ? [] : null;
        }

        const images = albumArtData.images || [];

        if (preference !== ALBUM_ART_PREFERENCE_ALL) {
            if (images.length === 0) {
                return null;
            }

            images.sort((a, b) => {
                const aTypeWeight = imageTypeKeyWeights[a[IMAGE_TYPE_KEY]];
                const bTypeWeight = imageTypeKeyWeights[b[IMAGE_TYPE_KEY]];
                return aTypeWeight - bTypeWeight;
            });

            const image = images[0];

            if (image[IMAGE_TYPE_KEY] === IMAGE_TYPE_BLOB) {
                return image.image;
            } else if (preference === ALBUM_ART_PREFERENCE_SMALLEST) {
                return image.thumbnails.small;
            } else {
                return image.image;
            }
        } else {
            return images.map(_.image);
        }
    }

    async getAlbumArt(trackUid, artist, album, preference = ALBUM_ART_PREFERENCE_SMALLEST) {
        const result = await this._getAlbumArt(trackUid, artist, album, preference);

        if (!result) {
            return result;
        } else if (Array.isArray(result)) {
            return result.map(this._mapToUrl, this);
        } else {
            return this._mapToUrl(result);
        }
    }
}
